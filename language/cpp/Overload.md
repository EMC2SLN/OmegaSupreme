***
在重载一个运算符为成员函数时，其参数表中没有任何参数，这说明该运算符是 （ ）
```
A. 无操作数的运算符
B. 二元运算符
C. 前缀一元运算符
D. 后缀一元运算符
```
** 答案：C**
首先可以判断是一元操作符。

因为++和--有前缀和后缀两种形式，为了区分，要求在后缀形式加一个int参数。  const Fraction operator ++(int)   中 int不过是个哑元（dummy）,是永远用不上的，它只是用来判断＋＋是prefix  还是  postfix  。如果有哑元，则是postfix,否则，就是prefix 。

同时定义前缀式操作符和后缀式操作符存在一个问题：它们的形参数目和类型相同，普通重载不能区别所定义的前缀式操作符还是后缀式操作符。为了解决这一问题，后缀式操作符函数接受一个额外的（即，无用的）int型形参。使用后缀式操作符进，编译器提供 0 作为这个形参的实参。尽管我们的前缀式操作符函数可以使用这个额外的形参，但通常不应该这样做。那个形参不是后缀式操作符的正常工作所需要的，它的唯一目的是使后缀函数与前缀函数区别开来。

(1) 双目运算符重载为类的成员函数时，函数只显式说明一个参数，该形参是运算符的右操作数。
(2) 前置单目运算符重载为类的成员函数时，不需要显式说明参数，即函数没有形参。
(3) 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。
***

***
考虑函数原型 void test(int a , int b = 7, char ch='*') ，下面的函数调用中，属于不合法调用的是（）
```
A. test(5)
B. test(5,8)
C. test(6,'#')
D. test(0,0,'#')
```
** 答案：C**
